package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"aseli-api/graph/database"
	"aseli-api/graph/generated"
	"aseli-api/graph/helper"
	"aseli-api/graph/model"
	"context"
	"fmt"
	"reflect"

	"github.com/99designs/gqlgen/graphql"
	surrealdb "github.com/surrealdb/surrealdb.go"
	"golang.org/x/crypto/bcrypt"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.RegisterRequest) (*model.RegisterResponse, error) {
	if input.Password != input.VerificationPassword {
		reason := "verification password"
		return &model.RegisterResponse{
			Success: false,
			Reason:  &reason,
		}, nil
	}

	db, err := database.Connect()
	if err != nil {
		panic(err)
	}

	if helper.User.CheckUsername(helper.User{}, db, input.Username) {
		reason := "username used"
		return &model.RegisterResponse{
			Success: false,
			Reason:  &reason,
		}, nil
	}

	hashed, _ := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	input.Password = string(hashed)

	modified := model.User{}
	surrealdb.Unmarshal(reflect.ValueOf(input).Interface(), &modified)
	modified.ProfileImage = nil

	data, err := db.Create("user", modified)
	if err != nil {
		panic(err)
	}

	user := model.User{}
	surrealdb.Unmarshal(reflect.ValueOf(data).Index(0).Interface(), &user)

	key := helper.User.RegisterAuthKey(helper.User{}, db, *user.ID)
	result := model.RegisterResponse{
		Success: true,
		AuthKey: &key,
	}

	defer db.Close()
	return &result, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginRequest) (*model.LoginResponse, error) {
	db, err := database.Connect()
	if err != nil {
		panic(err)
	}

	query, err := db.Query("SELECT id, password FROM user WHERE username=$username", input)
	if err != nil {
		panic(err)
	}

	user := model.User{}
	result := reflect.ValueOf(helper.NormalizeQueryResult(query))
	defer db.Close()

	success := result.Len() > 0

	reason := "wrong data"
	reasonAddr := &reason

	var key string
	if success {
		surrealdb.Unmarshal(result.Interface().([]interface{})[0], &user)
		if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
			success = false
		}
	}
	if success {
		key = helper.User.RegisterAuthKey(helper.User{}, db, *user.ID)
		reasonAddr = nil
	}

	return &model.LoginResponse{
		Success: success,
		AuthKey: &key,
		Reason:  reasonAddr,
	}, nil
}

// ChangeProfileImage is the resolver for the changeProfileImage field.
func (r *mutationResolver) ChangeProfileImage(ctx context.Context, image graphql.Upload) (string, error) {
	db, err := database.Connect()
	if err != nil {
		panic(err)
	}

	user := ctx.Value("user").(string)
	query, err := db.Query("SELECT profile_image FROM $user", map[string]interface{}{"user": user})
	if err != nil {
		panic(err)
	}

	res := helper.NormalizeQueryResult(query).([]interface{})[0]
	img := res.(map[string]interface{})["profile_image"]
	if img != nil {
		helper.DeleteImage(img.(string))
	}

	imgName := helper.SaveImage(image)
	db.Query("UPDATE $user SET profile_image=$profile_image", map[string]interface{}{
		"user":          user,
		"profile_image": &imgName,
	})

	defer db.Close()
	return imgName, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.UserResponse, error) {
	db, err := database.Connect()
	if err != nil {
		panic(err)
	}

	fields := helper.NormalizeFields(ctx)
	data, err := db.Query(fmt.Sprintf("SELECT %s FROM user", fields), nil)
	if err != nil {
		panic(err)
	}

	ndata := helper.NormalizeQueryResult(data)

	users := []*model.UserResponse{}
	surrealdb.Unmarshal(ndata, &users)

	defer db.Close()
	return users, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, username *string) (*model.UserResponse, error) {
	db, err := database.Connect()
	if err != nil {
		panic(err)
	}

	fields := helper.NormalizeFields(ctx)
	var data interface{}

	if username == nil {
		dat, err := db.Query(fmt.Sprintf("SELECT %s FROM $id", fields), map[string]interface{}{"id": ctx.Value("user").(string)})
		if err != nil {
			panic(err)
		}
		data = dat
	} else {
		dat, err := db.Query(fmt.Sprintf("SELECT %s FROM user WHERE username=$username", fields), map[string]interface{}{"username": &username})
		if err != nil {
			panic(err)
		}
		data = dat
	}

	ndata := helper.NormalizeQueryResult(data)

	users := []*model.UserResponse{}
	surrealdb.Unmarshal(ndata, &users)

	defer db.Close()

	user := &model.UserResponse{}
	if len(users) > 0 {
		user = users[0]
	}
	return user, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
