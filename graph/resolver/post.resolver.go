package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"aseli-api/graph/database"
	"aseli-api/graph/helper"
	"aseli-api/graph/model"
	"context"
	"fmt"
	"reflect"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	surrealdb "github.com/surrealdb/surrealdb.go"
	"golang.org/x/exp/slices"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, description string, image graphql.Upload) (*model.ResponseCreatePost, error) {
	if !slices.Contains([]string{"image/png", "image/jpeg"}, image.ContentType) {
		return nil, fmt.Errorf("file is not an image")
	}
	imgName := helper.Post.SaveImage(helper.Post{}, image)

	db, err := database.Connect()
	if err != nil {
		panic(err)
	}

	query, err := db.Create("post", &model.Post{
		User:        ctx.Value("user").(string),
		Title:       title,
		Description: description,
		Image:       imgName,
		Ril:         []string{},
		Fek:         []string{},
		Time:        helper.GetCurrentDateTime(),
		Comments:    []string{},
	})
	if err != nil {
		panic(err)
	}

	post := model.Post{}
	surrealdb.Unmarshal(reflect.ValueOf(query).Index(0).Interface(), &post)

	return &model.ResponseCreatePost{
		PostID: *post.ID,
	}, nil
}

// SendRil is the resolver for the sendRil field.
func (r *mutationResolver) SendRil(ctx context.Context, postID string) (*bool, error) {
	return helper.Post.SendRilOrFek(helper.Post{}, "ril", ctx, postID)
}

// SendFek is the resolver for the sendFek field.
func (r *mutationResolver) SendFek(ctx context.Context, postID string) (*bool, error) {
	return helper.Post.SendRilOrFek(helper.Post{}, "fek", ctx, postID)
}

// SendComment is the resolver for the sendComment field.
func (r *mutationResolver) SendComment(ctx context.Context, input model.RequestSendComment) (*model.ResponseSendComment, error) {
	db, err := database.Connect()
	if err != nil {
		panic(err)
	}

	comment, err := helper.Post.StoreComment(helper.Post{}, ctx, input)
	if err != nil {
		panic(err)
	}
	db.Query("UPDATE $post SET comments += $comment", map[string]interface{}{"post": input.PostID, "comment": comment.ID})

	resp := model.ResponseSendComment{
		CommentID: *comment.ID,
		Time:      comment.Time,
	}

	defer db.Close()
	return &resp, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.PostResponse, error) {
	db, err := database.Connect()
	if err != nil {
		panic(err)
	}
	fields := helper.NormalizeFieldsAsArray(ctx)

	// fields = strings.Replace(fields, "username", "user.username AS username", 1)
	fields = helper.ReplaceArrayValue(fields, "ril", "array::len(ril) AS ril")
	fields = helper.ReplaceArrayValue(fields, "fek", "array::len(fek) AS fek")

	fields = helper.ReplaceArrayValue(fields, "user_ril", fmt.Sprintf("array::find_index(ril, '%s') != NULL AS user_ril", ctx.Value("user").(string)))
	fields = helper.ReplaceArrayValue(fields, "user_fek", fmt.Sprintf("array::find_index(fek, '%s') != NULL AS user_fek", ctx.Value("user").(string)))

	cfields := strings.Join(fields, ",")

	sfields := helper.SplitFieldByName(cfields, "comments")
	sfields[0] = strings.Replace(sfields[0], "username", "user.username AS username", 1)

	cmtCmd := ""
	if len(sfields) > 1 {
		sfields[1] = strings.Replace(sfields[1], "username", "user.username AS username", 1)
		cmtCmd = fmt.Sprintf(", (SELECT %s OMIT user, post FROM comment) AS comments", sfields[1])
	}

	query, err := db.Query(fmt.Sprintf("SELECT %s%s OMIT user FROM post", sfields[0], cmtCmd), nil)
	if err != nil {
		panic(err)
	}

	ndata := helper.NormalizeQueryResult(query)
	posts := []*model.PostResponse{}
	surrealdb.Unmarshal(ndata, &posts)

	// resPosts := []*model.PostResponse{}
	// for _, post := range(posts) {
	// 	resPosts = append(resPosts, &model.PostResponse{
	// 		ID: post.ID,
	// 		Title: post.Title,
	// 		Description: post.Description,
	// 		Image: post.Image,
	// 		Username: post.Username,
	// 		Ril: len(post.Ril),
	// 		Fek: len(post.Fek),
	// 	})
	// }

	defer db.Close()
	return posts, nil
}
